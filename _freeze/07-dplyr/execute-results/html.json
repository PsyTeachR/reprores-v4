{
  "hash": "808432200f098de1bf7a0356d00cc87e",
  "result": {
    "engine": "knitr",
    "markdown": "# Data Wrangling {#dplyr}\n\n<div class=\"right meme\"><img src=\"images/memes/real_world_data.jpg\"\n     alt=\"A cute golden retriever labelled 'iris & mtcars' and a scary werewolf labelled 'Real world data'\" /></div>\n\n## Learning Objectives {#ilo-dplyr}\n\n### Basic {-}\n\n1. Be able to use the 6 main dplyr one-table verbs: [(video)](https://youtu.be/l12tNKClTR0){class=\"video\"}\n    + [`select()`](#select)\n    + [`filter()`](#filter)\n    + [`arrange()`](#arrange)\n    + [`mutate()`](#mutate)\n    + [`summarise()`](#summarise)\n    + [`group_by()`](#group_by)\n2. Be able to [wrangle data by chaining tidyr and dplyr functions](#all-together) [(video)](https://youtu.be/hzFFAkwrkqA){class=\"video\"} \n3. Be able to use these additional one-table verbs: [(video)](https://youtu.be/GmfF162mq4g){class=\"video\"}\n    + [`rename()`](#rename)\n    + [`distinct()`](#distinct)\n    + [`count()`](#count)\n    + [`slice()`](#slice)\n    + [`pull()`](#pull)\n\n### Intermediate {-}\n\n4. Fine control of [`select()` operations](#select_helpers) [(video)](https://youtu.be/R1bi1QwF9t0){class=\"video\"}\n5. Use [window functions](#window) [(video)](https://youtu.be/uo4b0W9mqPc){class=\"video\"}\n\n\n\n## Setup {#setup-dplyr}\n\n1. Open your `reprores-class-notes` project \n1. Create a new quarto file called `07-dplyr.Rmd`\n1. Update the YAML header \n1. Replace the setup chunk with the one below: \n\n\n::: {.cell layout-align=\"center\" verbatim='r setup, include = FALSE'}\n<div class='verbatim'><pre class='sourceCode r'><code class='sourceCode R'>&#96;&#96;&#96;{r setup, include = FALSE}</code></pre>\n\n```{.r .cell-code}\nknitr::opts_chunk$set(echo = TRUE)\n\n# packages needed for this chapter\nlibrary(tidyverse) # loads tidyr for pivot functions and tidy verbs\nlibrary(lubridate) # handling dates and times\n\nset.seed(8675309) # makes sure random numbers are reproducible\n```\n\n<pre class='sourceCode r'><code class='sourceCode R'>&#96;&#96;&#96;</code></pre></div>\n:::\n\n\n\nDownload the [Data transformation cheat sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf).\n\n### The `disgust` dataset {#data-disgust}\n\nThese examples will use data from the [Three Domain Disgust Scale](http://digitalrepository.unm.edu/cgi/viewcontent.cgi?article=1139&context=psy_etds). Each participant is identified by a unique `user_id` and each questionnaire completion has a unique `id`. Look at the Help for this dataset to see the individual questions.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndisgust <- read_csv(\"data/disgust.csv\")\n```\n:::\n\n\n\n## Six main dplyr verbs\n\nMost of the <a href='https://psyteachr.github.io/glossary/d#data-wrangling' target='_blank' class='glossary' title='The process of preparing data for visualisation and statistical analysis.'>data wrangling</a> you'll want to do with psychological data will involve the `tidyr` functions you learned in [Chapter 4](#tidyr) and the six main `dplyr` verbs: `select`, `filter`, `arrange`, `mutate`, `summarise`, and `group_by`.\n\n### select() {#select}\n\nSelect columns by name or number.\n\nYou can select each column individually, separated by commas (e.g., `col1, col2`). You can also select all columns between two columns by separating them with a colon (e.g., `start_col:end_col`).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmoral <- disgust |> select(user_id, moral1:moral7)\nnames(moral)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"user_id\" \"moral1\"  \"moral2\"  \"moral3\"  \"moral4\"  \"moral5\"  \"moral6\" \n[8] \"moral7\" \n```\n\n\n:::\n:::\n\n\nYou can select columns by number, which is useful when the column names are long or complicated.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsexual <- disgust |> select(2, 11:17)\nnames(sexual)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"user_id\" \"sexual1\" \"sexual2\" \"sexual3\" \"sexual4\" \"sexual5\" \"sexual6\"\n[8] \"sexual7\"\n```\n\n\n:::\n:::\n\n\nYou can use a minus symbol to unselect columns, leaving all of the other columns. If you want to exclude a span of columns, put parentheses around the span first (e.g., `-(moral1:moral7)`, not `-moral1:moral7`).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npathogen <- disgust |> select(-id, -date, -(moral1:sexual7))\nnames(pathogen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"user_id\"   \"pathogen1\" \"pathogen2\" \"pathogen3\" \"pathogen4\" \"pathogen5\"\n[7] \"pathogen6\" \"pathogen7\"\n```\n\n\n:::\n:::\n\n\n#### Select helpers {#select_helpers}\n\nYou can select columns based on criteria about the column names.\n\n##### `starts_with()` {#starts_with}\n\nSelect columns that start with a character string.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nu <- disgust |> select(starts_with(\"u\"))\nnames(u)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"user_id\"\n```\n\n\n:::\n:::\n\n\n##### `ends_with()` {#ends_with}\n\nSelect columns that end with a character string.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfirstq <- disgust |> select(ends_with(\"1\"))\nnames(firstq)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"moral1\"    \"sexual1\"   \"pathogen1\"\n```\n\n\n:::\n:::\n\n\n##### `contains()` {#contains}\n\nSelect columns that contain a character string.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npathogen <- disgust |> select(contains(\"pathogen\"))\nnames(pathogen)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"pathogen1\" \"pathogen2\" \"pathogen3\" \"pathogen4\" \"pathogen5\" \"pathogen6\"\n[7] \"pathogen7\"\n```\n\n\n:::\n:::\n\n\n##### `num_range()` {#num_range}\n\nSelect columns with a name that matches the pattern `prefix`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmoral2_4 <- disgust |> select(num_range(\"moral\", 2:4))\nnames(moral2_4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"moral2\" \"moral3\" \"moral4\"\n```\n\n\n:::\n:::\n\n\n::: {.info data-latex=\"\"}\nUse `width` to set the number of digits with leading\nzeros. For example, `num_range('var_', 8:10, width=2)` selects columns `var_08`, `var_09`, and `var_10`.\n:::\n\n### filter() {#filter}\n\nSelect rows by matching column criteria.\n\nSelect all rows where the user_id is 1 (that's Lisa). \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndisgust |> filter(user_id == 1)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id| user_id|date       | moral1| moral2| moral3| moral4| moral5| moral6| moral7| sexual1| sexual2| sexual3| sexual4| sexual5| sexual6| sexual7| pathogen1| pathogen2| pathogen3| pathogen4| pathogen5| pathogen6| pathogen7|\n|--:|-------:|:----------|------:|------:|------:|------:|------:|------:|------:|-------:|-------:|-------:|-------:|-------:|-------:|-------:|---------:|---------:|---------:|---------:|---------:|---------:|---------:|\n|  1|       1|2008-07-10 |      2|      2|      1|      2|      1|      1|      1|       3|       1|       1|       2|       1|       2|       2|         3|         2|         3|         3|         2|         3|         3|\n\n</div>\n:::\n:::\n\n\n::: {.warning data-latex=\"\"}\nRemember to use `==` and not `=` to check if two things are equivalent. A single `=` assigns the right-hand value to the left-hand variable and (usually) evaluates to `TRUE`.\n:::\n\nYou can select on multiple criteria by separating them with commas.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\namoral <- disgust |> filter(\n  moral1 == 0, \n  moral2 == 0,\n  moral3 == 0, \n  moral4 == 0,\n  moral5 == 0,\n  moral6 == 0,\n  moral7 == 0\n)\n```\n:::\n\n\nYou can use the symbols `&`, `|`, and `!` to mean \"and\", \"or\", and \"not\". You can also use other operators to make equations.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# everyone who chose either 0 or 7 for question moral1\nmoral_extremes <- disgust |> \n  filter(moral1 == 0 | moral1 == 7)\n\n# everyone who chose the same answer for all moral questions\nmoral_consistent <- disgust |> \n  filter(\n    moral2 == moral1 & \n    moral3 == moral1 & \n    moral4 == moral1 &\n    moral5 == moral1 &\n    moral6 == moral1 &\n    moral7 == moral1\n  )\n\n# everyone who did not answer 7 for all 7 moral questions\nmoral_no_ceiling <- disgust |>\n  filter(moral1+moral2+moral3+moral4+moral5+moral6+moral7 != 7*7)\n```\n:::\n\n\n#### Match operator (%in%) {#match-operator}\n\nSometimes you need to exclude some participant IDs for reasons that can't be described in code. The match operator (`%in%`) is useful here for testing if a column value is in a list. Surround the equation with parentheses and put `!` in front to test that a value is not in the list.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nno_researchers <- disgust |>\n  filter(!(user_id %in% c(1,2)))\n```\n:::\n\n\n\n#### Dates {#dates}\n\nYou can use the `lubridate` package to work with dates. For example, you can use the `year()` function to return just the year from the `date` column and then select only data collected in 2010.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndisgust2010 <- disgust |>\n  filter(year(date) == 2010)\n```\n:::\n\n\n\n\nTable: Rows 1-6 from `disgust2010`\n\n|   id| user_id|date       | moral1| moral2| moral3| moral4| moral5| moral6| moral7| sexual1| sexual2| sexual3| sexual4| sexual5| sexual6| sexual7| pathogen1| pathogen2| pathogen3| pathogen4| pathogen5| pathogen6| pathogen7|\n|----:|-------:|:----------|------:|------:|------:|------:|------:|------:|------:|-------:|-------:|-------:|-------:|-------:|-------:|-------:|---------:|---------:|---------:|---------:|---------:|---------:|---------:|\n| 6902|    5469|2010-12-06 |      0|      1|      3|      4|      1|      0|      1|       3|       5|       2|       4|       6|       6|       5|         5|         2|         4|         4|         2|         2|         6|\n| 6158|    6066|2010-04-18 |      4|      5|      6|      5|      5|      4|      4|       3|       0|       1|       6|       3|       5|       3|         6|         5|         5|         5|         5|         5|         5|\n| 6362|    7129|2010-06-09 |      4|      4|      4|      4|      3|      3|      2|       4|       2|       1|       3|       2|       3|       6|         5|         2|         0|         4|         5|         5|         4|\n| 6302|   39318|2010-05-20 |      2|      4|      1|      4|      5|      6|      0|       1|       0|       0|       1|       0|       0|       1|         3|         2|         3|         2|         3|         2|         4|\n| 5429|   43029|2010-01-02 |      1|      1|      1|      3|      6|      4|      2|       2|       0|       1|       4|       6|       6|       6|         4|         6|         6|         6|         6|         6|         4|\n| 6732|   71955|2010-10-15 |      2|      5|      3|      6|      3|      2|      5|       4|       3|       3|       6|       6|       6|       5|         4|         2|         6|         5|         6|         6|         3|\n\n\n\n\nOr select data from at least 5 years ago. You can use the `range` function to check the minimum and maximum dates in the resulting dataset.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndisgust_5ago <- disgust |>\n  filter(date < today() - dyears(5))\n\nrange(disgust_5ago$date)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2008-07-10\" \"2017-08-21\"\n```\n\n\n:::\n:::\n\n\n\n### arrange() {#arrange}\n\nSort your dataset using `arrange()`. You will find yourself needing to sort data in R much less than you do in Excel, since you don't need to have rows next to each other in order to, for example, calculate group means. But `arrange()` can be useful when preparing data from display in tables.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndisgust_order <- disgust |>\n  arrange(date, moral1)\n```\n:::\n\n\n\n\nTable: Rows 1-6 from `disgust_order`\n\n| id| user_id|date       | moral1| moral2| moral3| moral4| moral5| moral6| moral7| sexual1| sexual2| sexual3| sexual4| sexual5| sexual6| sexual7| pathogen1| pathogen2| pathogen3| pathogen4| pathogen5| pathogen6| pathogen7|\n|--:|-------:|:----------|------:|------:|------:|------:|------:|------:|------:|-------:|-------:|-------:|-------:|-------:|-------:|-------:|---------:|---------:|---------:|---------:|---------:|---------:|---------:|\n|  1|       1|2008-07-10 |      2|      2|      1|      2|      1|      1|      1|       3|       1|       1|       2|       1|       2|       2|         3|         2|         3|         3|         2|         3|         3|\n|  3|  155324|2008-07-11 |      2|      4|      3|      5|      2|      1|      4|       1|       0|       1|       2|       2|       6|       1|         4|         3|         1|         0|         4|         4|         2|\n|  6|  155386|2008-07-12 |      2|      4|      0|      4|      0|      0|      0|       6|       0|       0|       6|       4|       4|       6|         4|         5|         5|         1|         6|         4|         2|\n|  7|  155409|2008-07-12 |      4|      5|      5|      4|      5|      1|      5|       3|       0|       1|       5|       2|       0|       0|         5|         5|         3|         4|         4|         2|         6|\n|  4|  155366|2008-07-12 |      6|      6|      6|      3|      6|      6|      6|       0|       0|       0|       0|       0|       0|       3|         4|         4|         5|         5|         4|         6|         0|\n|  5|  155370|2008-07-12 |      6|      6|      4|      6|      6|      6|      6|       2|       6|       4|       3|       6|       6|       6|         6|         6|         6|         2|         4|         4|         6|\n\n\n\nReverse the order using `desc()`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndisgust_order_desc <- disgust |>\n  arrange(desc(date))\n```\n:::\n\n\n\n\nTable: Rows 1-6 from `disgust_order_desc`\n\n|    id| user_id|date       | moral1| moral2| moral3| moral4| moral5| moral6| moral7| sexual1| sexual2| sexual3| sexual4| sexual5| sexual6| sexual7| pathogen1| pathogen2| pathogen3| pathogen4| pathogen5| pathogen6| pathogen7|\n|-----:|-------:|:----------|------:|------:|------:|------:|------:|------:|------:|-------:|-------:|-------:|-------:|-------:|-------:|-------:|---------:|---------:|---------:|---------:|---------:|---------:|---------:|\n| 39456|  356866|2017-08-21 |      1|      1|      1|      1|      1|      1|      1|       1|       1|       1|       1|       1|       1|       1|         1|         1|         1|         1|         1|         1|         1|\n| 39447|  128727|2017-08-13 |      2|      4|      1|      2|      2|      5|      3|       0|       0|       1|       0|       0|       2|       1|         2|         0|         2|         1|         1|         1|         1|\n| 39371|  152955|2017-06-13 |      6|      6|      3|      6|      6|      6|      6|       1|       0|       0|       2|       1|       4|       4|         5|         0|         5|         4|         3|         6|         3|\n| 39342|   48303|2017-05-22 |      4|      5|      4|      4|      6|      4|      5|       2|       1|       4|       1|       1|       3|       1|         5|         5|         4|         4|         4|         4|         5|\n| 39159|  151633|2017-04-04 |      4|      5|      6|      5|      3|      6|      2|       6|       4|       0|       4|       0|       3|       6|         4|         4|         6|         6|         6|         6|         4|\n| 38942|  370464|2017-02-01 |      1|      5|      0|      6|      5|      5|      5|       0|       0|       0|       0|       0|       0|       0|         5|         0|         3|         3|         1|         6|         3|\n\n\n\n\n### mutate() {#mutate}\n\nAdd new columns. This is one of the most useful functions in the tidyverse.\n\nRefer to other columns by their names (unquoted). You can add more than one column in the same mutate function, just separate the columns with a comma. Once you make a new column, you can use it in further column definitions e.g., `total` below).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndisgust_total <- disgust |>\n  mutate(\n    pathogen = pathogen1 + pathogen2 + pathogen3 + pathogen4 + pathogen5 + pathogen6 + pathogen7,\n    moral = moral1 + moral2 + moral3 + moral4 + moral5 + moral6 + moral7,\n    sexual = sexual1 + sexual2 + sexual3 + sexual4 + sexual5 + sexual6 + sexual7,\n    total = pathogen + moral + sexual,\n    user_id = paste0(\"U\", user_id)\n  )\n```\n:::\n\n\n\n\nTable: Rows 1-6 from `disgust_total`\n\n|    id|user_id |date       | moral1| moral2| moral3| moral4| moral5| moral6| moral7| sexual1| sexual2| sexual3| sexual4| sexual5| sexual6| sexual7| pathogen1| pathogen2| pathogen3| pathogen4| pathogen5| pathogen6| pathogen7| pathogen| moral| sexual| total|\n|-----:|:-------|:----------|------:|------:|------:|------:|------:|------:|------:|-------:|-------:|-------:|-------:|-------:|-------:|-------:|---------:|---------:|---------:|---------:|---------:|---------:|---------:|--------:|-----:|------:|-----:|\n|  1199|U0      |2008-10-07 |      5|      6|      4|      6|      5|      5|      6|       4|       0|       1|       0|       1|       4|       5|         6|         1|         6|         5|         4|         5|         6|       33|    37|     15|    85|\n|     1|U1      |2008-07-10 |      2|      2|      1|      2|      1|      1|      1|       3|       1|       1|       2|       1|       2|       2|         3|         2|         3|         3|         2|         3|         3|       19|    10|     12|    41|\n|  1599|U2      |2008-10-27 |      1|      1|      1|      1|     NA|     NA|      1|       1|      NA|       1|      NA|       1|      NA|      NA|        NA|        NA|         1|        NA|        NA|        NA|        NA|       NA|    NA|     NA|    NA|\n| 13332|U2118   |2012-01-02 |      0|      1|      1|      1|      1|      2|      1|       4|       3|       0|       6|       0|       3|       5|         5|         6|         4|         6|         5|         5|         4|       35|     7|     21|    63|\n|    23|U2311   |2008-07-15 |      4|      4|      4|      4|      4|      4|      4|       2|       1|       2|       1|       1|       1|       5|         5|         5|         4|         4|         5|         4|         3|       30|    28|     13|    71|\n|  1160|U3630   |2008-10-06 |      1|      5|     NA|      5|      5|      5|      1|       0|       5|       0|       2|       0|       1|       0|         6|         3|         1|         1|         3|         1|         0|       15|    NA|      8|    NA|\n\n\n\n::: {.warning data-latex=\"\"}\nYou can overwrite a column by giving a new column the same name as the old column (see `user_id`) above. Make sure that you mean to do this and that you aren't trying to use the old column value after you redefine it.\n:::\n\n\n### summarise() {#summarise}\n\nCreate summary statistics for the dataset. Check the [Data Wrangling Cheat Sheet](https://www.rstudio.org/links/data_wrangling_cheat_sheet) or the [Data Transformation Cheat Sheet](https://github.com/rstudio/cheatsheets/raw/master/source/pdfs/data-transformation-cheatsheet.pdf) for various summary functions. Some common ones are: `mean()`, `sd()`, `n()`, `sum()`, and `quantile()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndisgust_summary <- disgust_total |>\n  summarise(\n    n = n(),\n    q25 = quantile(total, .25, na.rm = TRUE),\n    q50 = quantile(total, .50, na.rm = TRUE),\n    q75 = quantile(total, .75, na.rm = TRUE),\n    avg_total = mean(total, na.rm = TRUE),\n    sd_total  = sd(total, na.rm = TRUE),\n    min_total = min(total, na.rm = TRUE),\n    max_total = max(total, na.rm = TRUE)\n  )\n```\n:::\n\n\n\n\nTable: All rows from `disgust_summary`\n\n|     n| q25| q50| q75| avg_total| sd_total| min_total| max_total|\n|-----:|---:|---:|---:|---------:|--------:|---------:|---------:|\n| 20000|  59|  71|  83|   70.6868| 18.24253|         0|       126|\n\n\n\n\n### group_by() {#group_by}\n\nCreate subsets of the data. You can use this to create summaries, \nlike the mean value for all of your experimental groups.\n\nHere, we'll use `mutate` to create a new column called `year`, group by `year`, and calculate the average scores.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndisgust_groups <- disgust_total |>\n  mutate(year = year(date)) |>\n  group_by(year) |>\n  summarise(\n    n = n(),\n    avg_total = mean(total, na.rm = TRUE),\n    sd_total  = sd(total, na.rm = TRUE),\n    min_total = min(total, na.rm = TRUE),\n    max_total = max(total, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n```\n:::\n\n\n\n\nTable: All rows from `disgust_groups`\n\n| year|    n| avg_total| sd_total| min_total| max_total|\n|----:|----:|---------:|--------:|---------:|---------:|\n| 2008| 2578|  70.29975| 18.46251|         0|       126|\n| 2009| 2580|  69.74481| 18.61959|         3|       126|\n| 2010| 1514|  70.59238| 18.86846|         6|       126|\n| 2011| 6046|  71.34425| 17.79446|         0|       126|\n| 2012| 5938|  70.42530| 18.35782|         0|       126|\n| 2013| 1251|  71.59574| 17.61375|         0|       126|\n| 2014|   58|  70.46296| 17.23502|        19|       113|\n| 2015|   21|  74.26316| 16.89787|        43|       107|\n| 2016|    8|  67.87500| 32.62531|         0|       110|\n| 2017|    6|  57.16667| 27.93862|        21|        90|\n\n\n\n::: {.warning data-latex=\"\"}\nIf you don't add `.groups = \"drop\"` at the end of the `summarise()` function, you will get the following message: \"`summarise()` ungrouping output (override with `.groups` argument)\". This just reminds you that the groups are still in effect and any further functions will also be grouped. \n\nOlder versions of dplyr didn't do this, so older code will generate this warning if you run it with newer version of dplyr. Older code might  `ungroup()` after `summarise()` to indicate that groupings should be dropped. The default behaviour is usually correct, so you don't need to worry, but it's best to explicitly set `.groups` in a `summarise()` function after `group_by()` if you want to \"keep\" or \"drop\" the groupings. \n:::\n\nYou can use `filter` after `group_by`. The following example returns the lowest total score from each year (i.e., the row where the `rank()` of the value in the column `total` is equivalent to `1`).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndisgust_lowest <- disgust_total |>\n  mutate(year = year(date)) |>\n  select(user_id, year, total) |>\n  group_by(year) |>\n  filter(rank(total) == 1) |>\n  arrange(year)\n```\n:::\n\n\n\n\nTable: All rows from `disgust_lowest`\n\n|user_id | year| total|\n|:-------|----:|-----:|\n|U236585 | 2009|     3|\n|U292359 | 2010|     6|\n|U245384 | 2013|     0|\n|U206293 | 2014|    19|\n|U407089 | 2015|    43|\n|U453237 | 2016|     0|\n|U356866 | 2017|    21|\n\n\n\nYou can also use `mutate` after `group_by`. The following example calculates subject-mean-centered scores by grouping the scores by `user_id` and then subtracting the group-specific mean from each score. <span class=\"text-warning\">Note the use of `gather` to tidy the data into a long format first.</span>\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndisgust_smc <- disgust |>\n  gather(\"question\", \"score\", moral1:pathogen7) |>\n  group_by(user_id) |>\n  mutate(score_smc = score - mean(score, na.rm = TRUE)) |> \n  ungroup()\n```\n:::\n\n\n::: {.warning data-latex=\"\"}\nUse `ungroup()` as soon as you are done with grouped functions, otherwise the data table will still be grouped when you use it in the future.\n:::\n\n\n\nTable: Rows 1-6 from `disgust_smc`\n\n|    id| user_id|date       |question | score|  score_smc|\n|-----:|-------:|:----------|:--------|-----:|----------:|\n|  1199|       0|2008-10-07 |moral1   |     5|  0.9523810|\n|     1|       1|2008-07-10 |moral1   |     2|  0.0476190|\n|  1599|       2|2008-10-27 |moral1   |     1|  0.0000000|\n| 13332|    2118|2012-01-02 |moral1   |     0| -3.0000000|\n|    23|    2311|2008-07-15 |moral1   |     4|  0.6190476|\n|  1160|    3630|2008-10-06 |moral1   |     1| -1.2500000|\n\n\n\n\n### All Together {#all-together}\n\nA lot of what we did above would be easier if the data were tidy, so let's do that first. Then we can use `group_by` to calculate the domain scores.\n\nAfter that, we can spread out the 3 domains, calculate the total score, remove any rows with a missing (`NA`) total, and calculate mean values by year.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndisgust_tidy <- disgust |>\n  gather(\"question\", \"score\", moral1:pathogen7) |>\n  separate(question, c(\"domain\",\"q_num\"), sep = -1) |>\n  group_by(id, user_id, date, domain) |>\n  summarise(score = mean(score), .groups = \"drop\")\n```\n:::\n\n\n\n\nTable: Rows 1-6 from `disgust_tidy`\n\n| id| user_id|date       |domain   |    score|\n|--:|-------:|:----------|:--------|--------:|\n|  1|       1|2008-07-10 |moral    | 1.428571|\n|  1|       1|2008-07-10 |pathogen | 2.714286|\n|  1|       1|2008-07-10 |sexual   | 1.714286|\n|  3|  155324|2008-07-11 |moral    | 3.000000|\n|  3|  155324|2008-07-11 |pathogen | 2.571429|\n|  3|  155324|2008-07-11 |sexual   | 1.857143|\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndisgust_scored <- disgust_tidy |>\n  spread(domain, score) |>\n  mutate(\n    total = moral + sexual + pathogen,\n    year = year(date)\n  ) |>\n  filter(!is.na(total)) |>\n  arrange(user_id) \n```\n:::\n\n\n\n\nTable: Rows 1-6 from `disgust_scored`\n\n|    id| user_id|date       |    moral| pathogen|   sexual|     total| year|\n|-----:|-------:|:----------|--------:|--------:|--------:|---------:|----:|\n|  1199|       0|2008-10-07 | 5.285714| 4.714286| 2.142857| 12.142857| 2008|\n|     1|       1|2008-07-10 | 1.428571| 2.714286| 1.714286|  5.857143| 2008|\n| 13332|    2118|2012-01-02 | 1.000000| 5.000000| 3.000000|  9.000000| 2012|\n|    23|    2311|2008-07-15 | 4.000000| 4.285714| 1.857143| 10.142857| 2008|\n|  7980|    4458|2011-09-05 | 3.428571| 3.571429| 3.000000| 10.000000| 2011|\n|   552|    4651|2008-08-23 | 3.857143| 4.857143| 4.285714| 13.000000| 2008|\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndisgust_summarised <- disgust_scored |>\n  group_by(year) |>\n  summarise(\n    n = n(),\n    avg_pathogen = mean(pathogen),\n    avg_moral = mean(moral),\n    avg_sexual = mean(sexual),\n    first_user = first(user_id),\n    last_user = last(user_id),\n    .groups = \"drop\"\n  )\n```\n:::\n\n\n\n\nTable: Rows 1-6 from `disgust_summarised`\n\n| year|    n| avg_pathogen| avg_moral| avg_sexual| first_user| last_user|\n|----:|----:|------------:|---------:|----------:|----------:|---------:|\n| 2008| 2392|     3.697265|  3.806259|   2.539298|          0|    188708|\n| 2009| 2410|     3.674333|  3.760937|   2.528275|       6093|    251959|\n| 2010| 1418|     3.731412|  3.843139|   2.510075|       5469|    319641|\n| 2011| 5586|     3.756918|  3.806506|   2.628612|       4458|    406569|\n| 2012| 5375|     3.740465|  3.774591|   2.545701|       2118|    458194|\n| 2013| 1222|     3.771920|  3.906944|   2.549100|       7646|    462428|\n| 2014|   54|     3.759259|  4.000000|   2.306878|      11090|    461307|\n| 2015|   19|     3.781955|  4.451128|   2.375940|     102699|    460283|\n| 2016|    8|     3.696429|  3.625000|   2.375000|       4976|    453237|\n| 2017|    6|     3.071429|  3.690476|   1.404762|      48303|    370464|\n\n\n\n## Additional dplyr one-table verbs\n\nUse the code examples below and the help pages to figure out what the following one-table verbs do. Most have pretty self-explanatory names.\n\n### rename() {#rename}\n\nYou can rename columns with `rename()`. Set the argument name to the new name, and the value to the old name. You need to put a name in quotes or backticks if it doesn't follow the rules for a good variable name (contains only letter, numbers, underscores, and full stops; and doesn't start with a number).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsw <- starwars |>\n  rename(Name = name,\n         Height = height,\n         Mass = mass,\n         `Hair Colour` = hair_color,\n         `Skin Colour` = skin_color,\n         `Eye Colour` = eye_color,\n         `Birth Year` = birth_year)\n\nnames(sw)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Name\"        \"Height\"      \"Mass\"        \"Hair Colour\" \"Skin Colour\"\n [6] \"Eye Colour\"  \"Birth Year\"  \"sex\"         \"gender\"      \"homeworld\"  \n[11] \"species\"     \"films\"       \"vehicles\"    \"starships\"  \n```\n\n\n:::\n:::\n\n\n\n::: {.try data-latex=\"\"}\nAlmost everyone gets confused at some point with `rename()` and tries to put the original names on the left and the new names on the right. Try it and see what the error message looks like.\n:::\n\n### distinct() {#distinct}\n\nGet rid of exactly duplicate rows with `distinct()`. This can be helpful if, for example, you are merging data from multiple computers and some of the data got copied from one computer to another, creating duplicate rows.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# create a data table with duplicated values\ndupes <- tibble(\n  id = c( 1,   2,   1,   2,   1,   2),\n  dv = c(\"A\", \"B\", \"C\", \"D\", \"A\", \"B\")\n)\n\ndistinct(dupes)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|dv |\n|--:|:--|\n|  1|A  |\n|  2|B  |\n|  1|C  |\n|  2|D  |\n\n</div>\n:::\n:::\n\n\n### count() {#count}\n\nThe function `count()` is a quick shortcut for the common combination of `group_by()` and `summarise()` used to count the number of rows per group.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstarwars |>\n  group_by(sex) |>\n  summarise(n = n(), .groups = \"drop\")\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|sex            |  n|\n|:--------------|--:|\n|female         | 16|\n|hermaphroditic |  1|\n|male           | 60|\n|none           |  6|\n|NA             |  4|\n\n</div>\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncount(starwars, sex)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|sex            |  n|\n|:--------------|--:|\n|female         | 16|\n|hermaphroditic |  1|\n|male           | 60|\n|none           |  6|\n|NA             |  4|\n\n</div>\n:::\n:::\n\n\n\n### slice() {#slice}\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nslice(starwars, 1:3, 10)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|name           | height| mass|hair_color    |skin_color  |eye_color | birth_year|sex  |gender    |homeworld |species |films                                                                                                                                                                   |vehicles                                     |starships                                                                                                                        |\n|:--------------|------:|----:|:-------------|:-----------|:---------|----------:|:----|:---------|:---------|:-------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------|\n|Luke Skywalker |    172|   77|blond         |fair        |blue      |         19|male |masculine |Tatooine  |Human   |A New Hope             , The Empire Strikes Back, Return of the Jedi     , Revenge of the Sith    , The Force Awakens                                                   |Snowspeeder          , Imperial Speeder Bike |X-wing          , Imperial shuttle                                                                                               |\n|C-3PO          |    167|   75|NA            |gold        |yellow    |        112|none |masculine |Tatooine  |Droid   |A New Hope             , The Empire Strikes Back, Return of the Jedi     , The Phantom Menace     , Attack of the Clones   , Revenge of the Sith                        |                                             |                                                                                                                                 |\n|R2-D2          |     96|   32|NA            |white, blue |red       |         33|none |masculine |Naboo     |Droid   |A New Hope             , The Empire Strikes Back, Return of the Jedi     , The Phantom Menace     , Attack of the Clones   , Revenge of the Sith    , The Force Awakens |                                             |                                                                                                                                 |\n|Obi-Wan Kenobi |    182|   77|auburn, white |fair        |blue-gray |         57|male |masculine |Stewjon   |Human   |A New Hope             , The Empire Strikes Back, Return of the Jedi     , The Phantom Menace     , Attack of the Clones   , Revenge of the Sith                        |Tribubble bongo                              |Jedi starfighter        , Trade Federation cruiser, Naboo star skiff        , Jedi Interceptor        , Belbullab-22 starfighter |\n\n</div>\n:::\n:::\n\n\n### pull() {#pull}\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstarwars |>\n  filter(species == \"Droid\") |>\n  pull(name)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"C-3PO\"  \"R2-D2\"  \"R5-D4\"  \"IG-88\"  \"R4-P17\" \"BB8\"   \n```\n\n\n:::\n:::\n\n\n\n## Window functions {#window}\n\nWindow functions use the order of rows to calculate values. You can use them to do things that require ranking or ordering, like choose the top scores in each class, or accessing the previous and next rows, like calculating cumulative sums or means.\n\nThe [dplyr window functions vignette](https://dplyr.tidyverse.org/articles/window-functions.html) has very good detailed explanations of these functions, but we've described a few of the most useful ones below. \n\n### Ranking functions\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngrades <- tibble(\n  id = 1:5,\n  \"Data Skills\" = c(16, 17, 17, 19, 20), \n  \"Statistics\"  = c(14, 16, 18, 18, 19)\n) |>\n  gather(class, grade, 2:3) |>\n  group_by(class) |>\n  mutate(row_number = row_number(),\n         rank       = rank(grade),\n         min_rank   = min_rank(grade),\n         dense_rank = dense_rank(grade),\n         quartile   = ntile(grade, 4),\n         percentile = ntile(grade, 100))\n```\n:::\n\n\n\n\nTable: All rows from `grades`\n\n| id|class       | grade| row_number| rank| min_rank| dense_rank| quartile| percentile|\n|--:|:-----------|-----:|----------:|----:|--------:|----------:|--------:|----------:|\n|  1|Data Skills |    16|          1|  1.0|        1|          1|        1|          1|\n|  2|Data Skills |    17|          2|  2.5|        2|          2|        1|          2|\n|  3|Data Skills |    17|          3|  2.5|        2|          2|        2|          3|\n|  4|Data Skills |    19|          4|  4.0|        4|          3|        3|          4|\n|  5|Data Skills |    20|          5|  5.0|        5|          4|        4|          5|\n|  1|Statistics  |    14|          1|  1.0|        1|          1|        1|          1|\n|  2|Statistics  |    16|          2|  2.0|        2|          2|        1|          2|\n|  3|Statistics  |    18|          3|  3.5|        3|          3|        2|          3|\n|  4|Statistics  |    18|          4|  3.5|        3|          3|        3|          4|\n|  5|Statistics  |    19|          5|  5.0|        5|          4|        4|          5|\n\n\n\n::: {.try data-latex=\"\"}\n* What are the differences among `row_number()`, `rank()`, `min_rank()`, `dense_rank()`, and `ntile()`? \n* Why doesn't `row_number()` need an argument? \n* What would happen if you gave it the argument `grade` or `class`? \n* What do you think would happen if you removed the `group_by(class)` line above? \n* What if you added `id` to the grouping?\n* What happens if you change the order of the rows?\n* What does the second argument in `ntile()` do?\n:::\n\nYou can use window functions to group your data into quantiles.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsw_mass <- starwars |>\n  group_by(tertile = ntile(mass, 3)) |>\n  summarise(min = min(mass),\n            max = max(mass),\n            mean = mean(mass),\n            .groups = \"drop\")\n```\n:::\n\n\n\n\nTable: All rows from `sw_mass`\n\n| tertile| min|  max|     mean|\n|-------:|---:|----:|--------:|\n|       1|  15|   68|  45.6600|\n|       2|  74|   82|  78.4100|\n|       3|  83| 1358| 171.5789|\n|      NA|  NA|   NA|       NA|\n\n\n\n::: {.try data-latex=\"\"}\nWhy is there a row of `NA` values? How would you get rid of them? \n:::\n\n\n### Offset functions\n\nThe function `lag()` gives a previous row's value. It defaults to 1 row back, but you can change that with the `n` argument. The function `lead()` gives values ahead of the current row.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlag_lead <- tibble(x = 1:6) |>\n  mutate(lag = lag(x),\n         lag2 = lag(x, n = 2),\n         lead = lead(x, default = 0))\n```\n:::\n\n\n\n\nTable: All rows from `lag_lead`\n\n|  x| lag| lag2| lead|\n|--:|---:|----:|----:|\n|  1|  NA|   NA|    2|\n|  2|   1|   NA|    3|\n|  3|   2|    1|    4|\n|  4|   3|    2|    5|\n|  5|   4|    3|    6|\n|  6|   5|    4|    0|\n\n\n\nYou can use offset functions to calculate change between trials or where a value changes. Use the `order_by` argument to specify the order of the rows. Alternatively, you can use `arrange()` before the offset functions.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntrials <- tibble(\n  trial = sample(1:10, 10),\n  cond = sample(c(\"exp\", \"ctrl\"), 10, T),\n  score = rpois(10, 4)\n) |>\n  mutate(\n    score_change = score - lag(score, order_by = trial),\n    change_cond = cond != lag(cond, order_by = trial, \n                              default = \"no condition\")\n  ) |>\n  arrange(trial)\n```\n:::\n\n\n\n\nTable: All rows from `trials`\n\n| trial|cond | score| score_change|change_cond |\n|-----:|:----|-----:|------------:|:-----------|\n|     1|exp  |     4|           NA|TRUE        |\n|     2|ctrl |     4|            0|TRUE        |\n|     3|ctrl |     2|           -2|FALSE       |\n|     4|exp  |     3|            1|TRUE        |\n|     5|ctrl |     3|            0|TRUE        |\n|     6|ctrl |     8|            5|FALSE       |\n|     7|ctrl |     6|           -2|FALSE       |\n|     8|ctrl |     2|           -4|FALSE       |\n|     9|exp  |     6|            4|TRUE        |\n|    10|ctrl |     4|           -2|TRUE        |\n\n\n\n::: {.try data-latex=\"\"}\nLook at the help pages for `lag()` and `lead()`.\n\n* What happens if you remove the `order_by` argument or change it to `cond`?\n* What does the `default` argument do?\n* Can you think of circumstances in your own data where you might need to use `lag()` or `lead()`?\n:::\n\n### Cumulative aggregates\n\n`cumsum()`, `cummin()`, and `cummax()` are base R functions for calculating cumulative means, minimums, and maximums. The dplyr package introduces `cumany()` and `cumall()`, which return `TRUE` if any or all of the previous values meet their criteria.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncumulative <- tibble(\n  time = 1:10,\n  obs = c(2, 2, 1, 2, 4, 3, 1, 0, 3, 5)\n) |>\n  mutate(\n    cumsum = cumsum(obs),\n    cummin = cummin(obs),\n    cummax = cummax(obs),\n    cumany = cumany(obs == 3),\n    cumall = cumall(obs < 4)\n  )\n```\n:::\n\n\n\n\nTable: All rows from `cumulative`\n\n| time| obs| cumsum| cummin| cummax|cumany |cumall |\n|----:|---:|------:|------:|------:|:------|:------|\n|    1|   2|      2|      2|      2|FALSE  |TRUE   |\n|    2|   2|      4|      2|      2|FALSE  |TRUE   |\n|    3|   1|      5|      1|      2|FALSE  |TRUE   |\n|    4|   2|      7|      1|      2|FALSE  |TRUE   |\n|    5|   4|     11|      1|      4|FALSE  |FALSE  |\n|    6|   3|     14|      1|      4|TRUE   |FALSE  |\n|    7|   1|     15|      1|      4|TRUE   |FALSE  |\n|    8|   0|     15|      0|      4|TRUE   |FALSE  |\n|    9|   3|     18|      0|      4|TRUE   |FALSE  |\n|   10|   5|     23|      0|      5|TRUE   |FALSE  |\n\n\n\n::: {.try data-latex=\"\"}\n* What would happen if you change `cumany(obs == 3)` to `cumany(obs > 2)`?\n* What would happen if you change `cumall(obs < 4)` to `cumall(obs < 2)`?\n* Can you think of circumstances in your own data where you might need to use `cumany()` or `cumall()`?\n:::\n\n## Glossary {#glossary-dplyr}\n\n<table class=\"table\" style=\"margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> term </th>\n   <th style=\"text-align:left;\"> definition </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> &lt;a href='https://psyteachr.github.io/glossary/d#data-wrangling' target='_blank'&gt;data-wrangling&lt;/a&gt; </td>\n   <td style=\"text-align:left;\"> The process of preparing data for visualisation and statistical analysis. </td>\n  </tr>\n</tbody>\n</table>\n\n\n\n## Further Resources {#resources-dplyr}\n\n* [Chapter 5: Data Transformation](http://r4ds.had.co.nz/transform.html) in *R for Data Science*\n* [Data transformation cheat sheet](https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf)\n* [Chapter 16: Date and times](http://r4ds.had.co.nz/dates-and-times.html) in *R for Data Science*\n",
    "supporting": [
      "07-dplyr_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}